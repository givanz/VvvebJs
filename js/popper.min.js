/**
 * @popperjs/core v2.9.2 - MIT License
 */
"use strict";

(function (global, factory) {
    if (typeof exports === "object" && typeof module !== "undefined") {
        factory(exports);
    } else if (typeof define === "function" && define.amd) {
        define(["exports"], factory);
    } else {
        factory((global = typeof globalThis !== "undefined" ? globalThis : global || self).Popper = {});
    }
})(this, function (exports) {
    function getWindow(element) {
        return null == element ? window : "[object Window]" !== element.toString() ? (element = element.ownerDocument) && element.defaultView || window : element;
    }

    function getWindowScroll(node) {
        return {
            scrollLeft: (node = getWindow(node)).pageXOffset,
            scrollTop: node.pageYOffset
        };
    }

    function isElement(node) {
        return node instanceof getWindow(node).Element || node instanceof Element;
    }

    function isHTMLElement(node) {
        return node instanceof getWindow(node).HTMLElement || node instanceof HTMLElement;
    }

    function isShadowRoot(node) {
        return "undefined" != typeof ShadowRoot && (node instanceof getWindow(node).ShadowRoot || node instanceof ShadowRoot);
    }

    function nodeName(node) {
        return node ? (node.nodeName || "").toLowerCase() : null;
    }

    function getDocumentElement(element) {
        return t(getWindow(element)).left + getWindowScroll(element).scrollLeft;
    }

    function getComputedStyle(element) {
        return (element = c(element)), {
            overflow: element.overflow,
            overflowX: element.overflowX,
            overflowY: element.overflowY
        };
    }

    function isScrollParent(node) {
        var parent = node.parentNode;

        while (parent && parent !== node.ownerDocument.body) {
            if (l(parent)) return true;
            parent = parent.parentNode;
        }

        return false;
    }

    function getScrollParent(node) {
        var parent = node.parentNode;

        while (parent && parent !== node.ownerDocument.body) {
            if (l(parent)) return parent;
            parent = parent.parentNode;
        }

        return null;
    }

    function getOffsetParent(element) {
        var offsetParent = element.offsetParent;

        while (offsetParent && nodeName(offsetParent) !== "html" && getComputedStyle(offsetParent).position === "static") {
            offsetParent = offsetParent.offsetParent;
        }

        return offsetParent || element.ownerDocument.documentElement;
    }

    function isFixed(element) {
        return c(element).position === "fixed";
    }

    function getContainingBlock(element) {
        var currentNode = isHTMLElement(element) ? element : getOffsetParent(element);
        while (currentNode && ["html", "body", "#document"].indexOf(nodeName(currentNode)) < 0) {
            var css = getComputedStyle(currentNode);
            if (css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || (isFixed(currentNode) && css.overflow !== "visible")) {
                return currentNode;
            }
            currentNode = currentNode.parentNode;
        }
        return null;
    }

    function getMainAxisFromPlacement(placement) {
        return ["top", "bottom"].indexOf(placement) >= 0 ? "x" : "y";
    }

    function getAltAxis(axis) {
        return axis === "x" ? "y" : "x";
    }

    function mapToStyles(_ref) {
        var _ref2;

        var popper = _ref.popper,
            popperRect = _ref.popperRect,
            placement = _ref.placement,
            offsets = _ref.offsets,
            position = _ref.position,
            gpuAcceleration = _ref.gpuAcceleration,
            adaptive = _ref.adaptive,
            roundOffsets = _ref.roundOffsets;
        var x = Math.round(offsets.x);
        var y = Math.round(offsets.y);
        var hasX = ["left", "right"].indexOf(placement) !== -1;
        var hasY = ["top", "bottom"].indexOf(placement) !== -1;
        var sideX = hasX ? "top" : "left";
        var sideY = hasY ? "left" : "top";
        var css = {
            position: position,
            left: x,
            top: y,
            // Firefox prevents this from being applied to the popper element
            // with `position: fixed` - https://bugzilla.mozilla.org/show_bug.cgi?id=208427
            // - see also https://github.com/popperjs/popper-core/issues/1076
            // - removing the transform from the arrow fixes the issue
            transform: "translate" + (_ref2 = hasX ? "Y" : "X") + "(" + (hasX ? (gpuAcceleration ? "calc(50% - " + popperRect.width / 2 + "px)" : x) : (gpuAcceleration ? "calc(50% - " + popperRect.height / 2 + "px)" : y)) + ")",
        };
        // rounding coordinates if needed
        if (roundOffsets) {
            css[sideX] = Math.round(x);
            css[sideY] = Math.round(y);
        }
        return css;
    }

    function computeStyles(_ref3) {
        var state = _ref3.state,
            options = _ref3.options;
        var _options$gpuAccelerat = options.gpuAcceleration,
            gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,
            _options$adaptive = options.adaptive,
            adaptive = _options$adaptive === void 0 ? true : _options$adaptive,
            _options$roundOffsets = options.roundOffsets,
            roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;
        {
            var _state$elements = state.elements,
                popper = _state$elements.popper,
                reference = _state$elements.reference;
            var placement = state.placement.split("-")[0];
            var popperOffsets = state.modifiersData.popperOffsets;
            var data = Object.assign({}, popperOffsets, {
                placement: state.placement
            });
            state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles({
                popper: popper,
                popperRect: state.rects.popper,
                placement: placement,
                offsets: data,
                position: state.options.strategy,
                gpuAcceleration: gpuAcceleration,
                adaptive: adaptive,
                roundOffsets: roundOffsets
            }));
        }
    }

    function createPopperLite(reference, popper, options) {
        var state = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, F, options),
            modifiersData: {},
            elements: {
                reference: reference,
                popper: popper
            },
            attributes: {},
            styles: {}
        };
        var instance = {
            state: state,
            setOptions: function setOptions(options) {
                Object.assign(state.options, options);
                state.scrollParents = {
                    reference: isElement(reference) ? getScrollParent(reference) : reference.contextElement ? getScrollParent(reference.contextElement) : [],
                    popper: getScrollParent

(popper)
                };
                var orderedModifiers = orderModifiers(mergeByName([].concat(G, state.options.modifiers)));
                state.orderedModifiers = orderedModifiers.filter(function (m) {
                    return m.enabled;
                });
                runModifierEffect("update", instance);
            },
            // Syncronous and method to get updated modifiers list
            forceUpdate: function forceUpdate() {
                if (!R) {
                    return;
                }
                var _state$elements2 = state.elements,
                    reference = _state$elements2.reference,
                    popper = _state$elements2.popper;
                // Don't proceed if `reference` or `popper` are not valid elements anymore
                // or if Popper is deactivated
                if (!isElement(reference) || !isElement(popper) || !state.enabled) {
                    return;
                }
                var _state$modifiers = state.modifiersData,
                    lastModifiersData = _state$modifiers.lastModifiersData;
                // Don't do anything if the list of modifiers didn't change
                // since the last `forceUpdate`
                if (areModifiersEquivalent(lastModifiersData, state.orderedModifiers)) {
                    return;
                }
                state.modifiersData.lastModifiersData = state.orderedModifiers.map(function (modifier) {
                    return Object.assign({}, modifier);
                });
                // First, update the model to compute the new `offsets`
                // and `placement`
                state.rects = {
                    reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === "fixed"),
                    popper: getLayoutRect(popper)
                };
                // Then, update the modifiers data...
                state.modifiersData = {};
                for (var index = 0; index < state.orderedModifiers.length; index++) {
                    var modifier = state.orderedModifiers[index];
                    var _modifier = modifier,
                        _modifier$fn = _modifier.fn,
                        fn = _modifier$fn === void 0 ? modifier : _modifier$fn,
                        _modifier$options = _modifier.options,
                        options = _modifier$options === void 0 ? {} : _modifier$options,
                        name = _modifier.name;
                    if (typeof fn === "function") {
                        state = fn({
                            state: state,
                            options: options,
                            name: name,
                            instance: instance
                        });
                    }
                }
            },
            // Async method
            update: function update() {
                return new Promise(function (resolve) {
                    instance.forceUpdate();
                    resolve(state);
                });
            },
            destroy: function destroy() {
                R = false;
                A();
            }
        };
        // Apply initial config
        instance.setOptions(options);
        return instance;
    }

    exports.createPopperLite = createPopperLite;
    exports.default = createPopperLite;
});
```//# sourceMappingURL=popper.min.js.map
